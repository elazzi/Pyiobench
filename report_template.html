<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iostat Metrics Report</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        h1 { text-align: center; color: #2c3e50; }
        .controls { margin-bottom: 20px; padding: 15px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; align-items: flex-start; gap: 15px; }
        .controls > label { font-weight: bold; margin-right: 5px; margin-bottom: 5px; display: block; padding-top: 5px; }
        #metricCheckboxes {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f9f9f9;
            min-width: 300px;
            max-height: 300px;
            overflow-y: auto;
        }
        .device-metric-group { margin-bottom: 10px; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .device-metric-group:last-child { border-bottom: none; }
        .device-metric-group h3 { font-size: 1.1em; margin-top: 0; margin-bottom: 8px; color: #34495e; }
        .metric-options { display: flex; flex-wrap: wrap; gap: 8px; }
        .metric-options label { margin-right: 10px; font-weight: normal; display: inline-flex; align-items: center; font-size: 0.9em; background-color: #e9ecef; padding: 3px 6px; border-radius: 3px; cursor: pointer;}
        .metric-options input[type="checkbox"] { margin-right: 5px; }
        .metric-max-value { font-size: 0.8em; color: #7f8c8d; margin-left: 4px; }
        #graphDisplayArea {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 20px;
            padding-top: 20px;
        }
        .graph-container {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            height: 380px; /* Increased height for D3 chart with title and axes */
            position: relative;
            display: flex;
            flex-direction: column;
        }
        .chart-title { /* Class for the <p> title element */
            font-size: 1em; color: #555; margin-bottom: 10px; font-weight: bold; text-align: center;
            flex-shrink: 0; /* Prevent title from shrinking */
        }
        .d3-svg-container { /* Div that will contain the SVG */
            flex-grow: 1; /* SVG container takes remaining space */
            position: relative; /* For SVG positioning if needed */
        }
        /* D3 specific styles */
        .line { fill: none; stroke: steelblue; stroke-width: 1.5px; }
        .axis path, .axis line { fill: none; stroke: #ccc; shape-rendering: crispEdges; } /* Lighter axis lines */
        .axis text { font-family: sans-serif; font-size: 10px; fill: #555 } /* Axis text color */
        .axis-label { font-size: 12px; fill: #333; text-anchor: middle; }
        /* Tooltip style (optional, if you add tooltips) */
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 6px;
            font: 12px sans-serif;
            background: rgba(50,50,50,0.8);
            color: white;
            border: 0px;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
    </style>
</head>
<body>
    <h1>iostat Metrics Report</h1>

    <div class="controls">
        <label>Select Metrics to Display:</label>
        <div id="metricCheckboxes">
            <!-- Checkboxes for devices and their metrics will be populated here by JavaScript -->
        </div>
    </div>

    <div id="graphDisplayArea">
        <!-- D3 charts will be appended here -->
    </div>

    <script>
        const graphData = JSON.parse('__GRAPH_DATA_JSON__');
        // const activeCharts = {}; // D3 typically doesn't require storing instances like Chart.js for simple redraw/removal

        const metricCheckboxesContainer = document.getElementById('metricCheckboxes');
        const graphDisplayArea = document.getElementById('graphDisplayArea');

        function initializeMetricSelectors() {
            metricCheckboxesContainer.innerHTML = '';

            const devices = Object.keys(graphData);
            if (devices.length === 0) {
                metricCheckboxesContainer.innerHTML = '<p>No devices found in data.</p>';
                return;
            }

            devices.forEach(device => {
                const deviceGroupDiv = document.createElement('div');
                deviceGroupDiv.className = 'device-metric-group';

                const deviceTitle = document.createElement('h3');
                deviceTitle.textContent = `Device: ${device}`;
                deviceGroupDiv.appendChild(deviceTitle);

                const metricsContainer = document.createElement('div');
                metricsContainer.className = 'metric-options';

                const metrics = Object.keys(graphData[device]);
                if (metrics.length === 0) {
                    metricsContainer.innerHTML = '<span>No metrics found for this device.</span>';
                } else {
                    metrics.forEach(metric => {
                        const checkboxId = `checkbox-${device}-${metric}`;
                        const label = document.createElement('label');
                        label.setAttribute('for', checkboxId);

                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = checkboxId;
                        checkbox.dataset.device = device;
                        checkbox.dataset.metric = metric;

                        checkbox.addEventListener('change', handleD3CheckboxChange);

                        label.appendChild(checkbox);

                        let labelText = metric;
                        const metricInfo = graphData[device][metric];
                        if (metricInfo && typeof metricInfo.max_value !== 'undefined') {
                            let maxText = '(Max: N/A)';
                            if (metricInfo.max_value !== null) {
                                maxText = `(Max: ${parseFloat(metricInfo.max_value).toFixed(2)})`;
                            }
                            labelText += ` <span class="metric-max-value">${maxText}</span>`;
                        }

                        const textSpan = document.createElement('span');
                        textSpan.innerHTML = labelText;
                        label.appendChild(textSpan);

                        metricsContainer.appendChild(label);
                    });
                }
                deviceGroupDiv.appendChild(metricsContainer);
                metricCheckboxesContainer.appendChild(deviceGroupDiv);
            });
        }

        function handleD3CheckboxChange(event) {
            const checkbox = event.target;
            const device = checkbox.dataset.device;
            const metric = checkbox.dataset.metric;
            const graphContainerId = `d3-graph-container-${device}-${metric}`;

            if (checkbox.checked) {
                if (!document.getElementById(graphContainerId) && graphData[device] && graphData[device][metric]) {
                    const item = graphData[device][metric];

                    const graphContainer = document.createElement('div');
                    graphContainer.className = 'graph-container';
                    graphContainer.id = graphContainerId;

                    const titleElement = document.createElement('p');
                    titleElement.className = 'chart-title';
                    titleElement.textContent = item.title;
                    graphContainer.appendChild(titleElement);

                    const svgContainer = document.createElement('div'); // This div will directly contain the SVG
                    svgContainer.className = 'd3-svg-container';
                    graphContainer.appendChild(svgContainer);

                    graphDisplayArea.appendChild(graphContainer);
                    drawD3Chart(svgContainer, item.series_data, item.title, item.max_value, metric);
                }
            } else {
                const graphElement = document.getElementById(graphContainerId);
                if (graphElement) {
                    graphDisplayArea.removeChild(graphElement);
                }
            }
        }

        function drawD3Chart(containerElement, seriesData, chartTitleText, metricMaxValue, metricName) {
            const data = seriesData.timestamps.map((ts, i) => ({
                date: d3.isoParse(ts), // Use d3.isoParse for ISO strings
                value: seriesData.values[i]
            })).filter(d => d.value !== null && d.date !== null); // Filter out null dates or values

            if (data.length === 0) {
                containerElement.innerHTML = '<p>No valid data to display for this metric.</p>';
                return;
            }

            const margin = {top: 10, right: 30, bottom: 40, left: 50}; // Adjusted margins

            // Get dimensions from the .d3-svg-container which is set to flex-grow
            const parentRect = containerElement.getBoundingClientRect();
            const width = parentRect.width - margin.left - margin.right;
            const height = parentRect.height - margin.top - margin.bottom;

            if (width <=0 || height <=0) { // If container has no size yet, don't draw
                containerElement.innerHTML = '<p>Cannot draw chart: container has no dimensions.</p>';
                return;
            }

            const svg = d3.select(containerElement).append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
              .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const xScale = d3.scaleTime()
                .domain(d3.extent(data, d => d.date))
                .range([0, width]);

            const effectiveMaxValue = d3.max(data, d => d.value);
            const yDomainMax = Math.max(effectiveMaxValue, metricMaxValue, (metricMaxValue === null && effectiveMaxValue === 0 ? 10 : 0)); // Ensure y-axis isn't flat if all 0

            const yScale = d3.scaleLinear()
                .domain([0, yDomainMax]).nice() // Use .nice() for better axis ticks
                .range([height, 0]);

            const xAxis = d3.axisBottom(xScale).ticks(Math.max(Math.floor(width / 80), 2)).tickFormat(d3.timeFormat("%H:%M:%S"));
            const yAxis = d3.axisLeft(yScale).ticks(Math.max(Math.floor(height/30), 2));

            svg.append("g")
                .attr("class", "axis x-axis")
                .attr("transform", `translate(0,${height})`)
                .call(xAxis)
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-35)");

            svg.append("g")
                .attr("class", "axis y-axis")
                .call(yAxis);

            // Y-axis label
            svg.append("text")
                .attr("class", "axis-label")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 15) // Adjust position
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em") // Keep it away from axis line
                .style("text-anchor", "middle")
                .text(metricName);


            const line = d3.line()
                .defined(d => d.value !== null) // Handles gaps for null data
                .x(d => xScale(d.date))
                .y(d => yScale(d.value));

            svg.append("path")
                .datum(data)
                .attr("class", "line")
                .attr("d", line);

            // Zoom functionality
            const zoom = d3.zoom()
                .scaleExtent([1, 20]) // Min 1x, Max 20x zoom
                .translateExtent([[0, 0], [width, height]]) // Pan within original chart bounds
                .extent([[0, 0], [width, height]])
                .on("zoom", (event) => {
                    const newXScale = event.transform.rescaleX(xScale);
                    const newYScale = event.transform.rescaleY(yScale);

                    svg.select(".x-axis").call(d3.axisBottom(newXScale).ticks(Math.max(Math.floor(width / 80), 2)).tickFormat(d3.timeFormat("%H:%M:%S")))
                       .selectAll("text").style("text-anchor", "end").attr("dx", "-.8em").attr("dy", ".15em").attr("transform", "rotate(-35)");
                    svg.select(".y-axis").call(d3.axisLeft(newYScale).ticks(Math.max(Math.floor(height/30), 2)));

                    svg.select(".line").attr("d", line.x(d => newXScale(d.date)).y(d => newYScale(d.value)));
                });

            // Append a rect for capturing zoom events, ensuring it's behind the lines/axes
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .call(zoom);
        }

        initializeMetricSelectors();
    </script>
</body>
</html>
